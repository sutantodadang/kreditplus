// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: customers_limits.sql

package repositories

import (
	"context"
)

const createCustomersLimits = `-- name: CreateCustomersLimits :copyfrom
INSERT INTO kp_customers_limits (
    customer_limit_id,
    customer_id,
    limit_amount,
    tenor
) VALUES (?, ?, ?, ?)
`

type CreateCustomersLimitsParams struct {
	CustomerLimitID string `db:"customer_limit_id" json:"customer_limit_id"`
	CustomerID      string `db:"customer_id" json:"customer_id"`
	LimitAmount     string `db:"limit_amount" json:"limit_amount"`
	Tenor           int32  `db:"tenor" json:"tenor"`
}

const getCustomerLimitById = `-- name: GetCustomerLimitById :many
SELECT customer_limit_id, customer_id, limit_amount, tenor FROM kp_customers_limits WHERE customer_id = ?
`

type GetCustomerLimitByIdRow struct {
	CustomerLimitID string `db:"customer_limit_id" json:"customer_limit_id"`
	CustomerID      string `db:"customer_id" json:"customer_id"`
	LimitAmount     string `db:"limit_amount" json:"limit_amount"`
	Tenor           int32  `db:"tenor" json:"tenor"`
}

func (q *Queries) GetCustomerLimitById(ctx context.Context, customerID string) ([]GetCustomerLimitByIdRow, error) {
	rows, err := q.query(ctx, q.getCustomerLimitByIdStmt, getCustomerLimitById, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCustomerLimitByIdRow
	for rows.Next() {
		var i GetCustomerLimitByIdRow
		if err := rows.Scan(
			&i.CustomerLimitID,
			&i.CustomerID,
			&i.LimitAmount,
			&i.Tenor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
